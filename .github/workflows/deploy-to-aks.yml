name: Build and Deploy to AKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_CONTAINER_REGISTRY: booklistregistry2617
  RESOURCE_GROUP: booklist-k8s
  CLUSTER_NAME: booklist-aks
  NAMESPACE: booklist

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend/BookListApi
        push: true
        tags: |
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/booklist-api:latest
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/booklist-api:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend/book-list-app
        push: true
        tags: |
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/booklist-frontend:latest
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/booklist-frontend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }} --overwrite-existing

    - name: Replace placeholders in Kubernetes manifests
      run: |
        # Replace connection string placeholders with actual values
        sed -i "s|PLACEHOLDER_COSMOS_DB_CONNECTION_STRING|${{ secrets.COSMOS_DB_CONNECTION_STRING }}|g" k8s/00-namespace-config.yaml
        sed -i "s|PLACEHOLDER_BLOB_STORAGE_CONNECTION_STRING|${{ secrets.BLOB_STORAGE_CONNECTION_STRING }}|g" k8s/00-namespace-config.yaml

    - name: Deploy to AKS
      run: |
        # Apply Kubernetes manifests
        kubectl apply -f k8s/00-namespace-config.yaml
        kubectl apply -f k8s/01-backend-deployment.yaml
        kubectl apply -f k8s/02-frontend-deployment.yaml
        kubectl apply -f k8s/03-ingress.yaml
        kubectl apply -f k8s/04-hpa.yaml

        # Wait for deployments to be ready
        kubectl rollout status deployment/booklist-api -n ${{ env.NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/booklist-frontend -n ${{ env.NAMESPACE }} --timeout=300s

    - name: Get service information
      run: |
        echo "=== Services ==="
        kubectl get services -n ${{ env.NAMESPACE }}
        echo "=== Pods ==="
        kubectl get pods -n ${{ env.NAMESPACE }}
        echo "=== Ingress ==="
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        # Get LoadBalancer IP if available
        echo "=== LoadBalancer IP ==="
        kubectl get service booklist-loadbalancer -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "LoadBalancer IP not ready yet"

    - name: Run health checks
      run: |
        # Wait for LoadBalancer IP to be assigned
        echo "Waiting for LoadBalancer IP..."
        for i in {1..30}; do
          LB_IP=$(kubectl get service booklist-loadbalancer -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ ! -z "$LB_IP" ]; then
            echo "LoadBalancer IP: $LB_IP"
            
            # Test backend health endpoint
            echo "Testing backend health..."
            curl -f "http://$LB_IP/health" || echo "Health check failed"
            
            # Test frontend
            echo "Testing frontend..."
            curl -f "http://$LB_IP/" || echo "Frontend check failed"
            
            break
          fi
          echo "Waiting for LoadBalancer IP... (attempt $i/30)"
          sleep 10
        done